{
  "hash": "9ec4a3dd87f18a03cf57791a0d5dc800",
  "result": {
    "engine": "knitr",
    "markdown": "---\n#title: \"Risk and Return\"\nauthor: \"Lucas S. Macoris\"\nformat:\n  revealjs:\n    title: 'Manipulating time series Data'\n    incremental: false\n    theme: [default, ../~ Metadata/custom.scss]\n    auto-stretch: false\n    author: 'Lucas S. Macoris'\n    logo: 'Images/logo.jpg'\n    footer: \"[@ Website](https://lsmacoris.github.io/) | [@ Slides](https://lsmacoris.github.io/lectures/quant-fin) | [@ Office-hour appointments](https://calendly.com/lucas-macoris-fgv/appointment-lsm)\"\n    toc: false\n    cls: '../~ Metadata/abntex2.cls'\n    bibliography: '../~ Metadata/Bibliography.bib'\n    slide-number: true\n    show-slide-number: all\n    transition: slide\n    background-transition: fade\n    chalkboard: true\n    width: 1600\n    height: 900\n    smaller: false\n\neditor: visual\nfrom: markdown+emoji\n---\n\n::: {.cell}\n\n:::\n\n\n\n## Outline\n\n-   This lecture is mainly based the following textbooks:\n    1.  *Tidy Finance* [@tidyfinance]\n    2.  *R for Data Science* [@r4ds]\n\n::: callout-note\n### Coding Replications\n\nFor coding replications, whenever applicable, please follow [this](https://lsmacoris.github.io/lectures/quant-fin.html) page or hover on the specific slides with containing coding chunks.\n\n1.  Ensure that you have your [{{<fa brands r-project>}}]{.blue} session properly set-up according to the instructions outlined in the course webpage\n2.  Along with the slides, this lecture will also contain a replication file, in `.qmd` format, containing a thorough discussion for all examples that have been showcased. This file, that will be posted on *eClass®*, can be downloaded and replicated on your side. To do that, download the file, open it up in *RStudio*, and render the Quarto document using the *Render* button (shortcut: `Ctrl+Shift+K`).\n3.  At the end of this lecture, you will be prompted with a hands-on exercise to test your skills using the tools you've learned as you made your way through the slides. A suggested solution will be provided in the replication file.\n:::\n\n## Organizing Financial Data\n\n-   In the previous lecture, you worked your way through the exercises by using the amazing `dplyr` functionalities on `data.frames`\n\n-   In some cases, you had to do some workarounds with `drop_na()`, `slice_tail()` and `lag()` simply because you were manipulating time series data\n\n-   In this lecture, you will be introduced to a particular type of class in `R`: `xts`\n\n. . .\n\n::: callout-tip\n### Definition\n\n`xts` is an `R` package that provides an extension of the `zoo` class, a class with methods for totally ordered indexed observations - in special, [time series]{.blue}\n\n-   With `xts`, you get a lot of flexibility in handling time series observations that are of interest of financial analysts, such as:\n\n    1.  Subsetting data by years/months/days\n    2.  Calculating rolling functions (*e.g*, yearly averages)\n    3.  Aggregating data at different intervals (*e.g*, convert daily to weekly prices)\n:::\n\n. . .\n\n**Question:** but wait, why are we departing from `dplyr`?\n\n## Bridging the `tidyverse` with time series\n\n-   Unfortunately, there is an issue: the `tidyverse` is not fully designed to work with time series classes, such as `xts` and `zoo`\n\n-   As a consequence, you won't be able to use a lot of interesting functionalities that would perfectly apply for time series\n\n    1.  But don't you worry, I got you covered: the `tidyquant` package[^1] integrates the best resources for collecting and analyzing financial data\n\n    2.  It integrates several financial packages, like `zoo`, `xts`, `quantmod`, `TTR`, and `PerformanceAnalytics`, with the tidy data infrastructure of the `tidyverse`, allowing for seamless interaction between each\n\n-   You can now perform complete financial analyses using the same functionalities you've learned so far!\n\n[^1]: Click [here](https://business-science.github.io/tidyquant/) for a thorough documentation on the `tidyquant` package.\n\n## The `tidyquant` package, a short-video\n\n{{< video https://www.youtube.com/embed/woxJZTL2hok width=\"800\" height=\"600\">}}\n\n## The `tq_mutate()` function\n\n::: callout-tip\n### Definition\n\nThe `tq_mutate()` function adds adds new variables to an existing `tibble`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntq_mutate(.data, #The object you are performing the calculations \n       selected_variables, #The columns to send to the mutation function\n       mutate_fun, #The mutation function from either the xts, quantmod, or TTR package.\n       col_rename #A string or character vector containing names that can be used to quickly rename columns\n       ) \n```\n:::\n\n\n:::\n\n1.  The main advantage is the results are returned as a `tibble` and the function can be used with the `tidyverse`\n2.  It is used when you expected additional columns to be added to the resulting data frame\n3.  You can use several time series related functions from other `R` packages - call `tq_mutate_fun_options()` to see the list of available options\n4.  All in all, it is similar in spirit to `mutate()`\n\n## The `tq_transmute()` function\n\n::: callout-tip\n### Definition\n\nThe `tq_transmute()` returns only newly created columns and is typically used when periodicity changes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntq_transmute(.data, #The object you are performing the calculations \n       selected_variables, #The columns to send to the mutation function\n       mutate_fun, #The mutation function from either the xts, quantmod, or TTR package.\n       col_rename #A string or character vector containing names that can be used to quickly rename columns\n       )\n```\n:::\n\n\n:::\n\n1.  `tq_transmute()` works exactly like `tq_mutate()` except it only returns the newly created columns\n2.  This is helpful when changing periodicity where the new columns would not have the same number of rows as the original tibble\n3.  All in all, it is similar in spirit to `summarize()`\n\n## Working with time series objects, Exercise I\n\n-   An immediate useful example of using a time series specific functionality with a tidyverse logic relates to [filtering]{.blue}:\n    1.  Sometimes, we may be interested in getting only a subset of the data (for example, only *GOOG* information)\n    2.  Furthermore, we may be interested in subsetting only a specific time frame for our analysis\n-   It is relatively straightforward to do it with `tidyquant`:\n    1.  Use `filter()` to select only rows where `symbol=='GOOG'`\n    2.  In the same call, filter for `date`\\>= `min_date` and `date`\\<=`max_date`\n\n## Working with time series objects, Exercise I\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyquant)\nlibrary(tidyverse)\n\n#Set up the list of assets\nassets=c('AMZN','GOOG','META','GME')\n\n#Filter out\nassets%>%\n  tq_get()%>%\n  filter(symbol=='GOOG',\n         date>='2020-01-01',\n         date<='2024-12-31')\n```\n:::\n\n\n\n### Output\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,258 × 8\n   symbol date        open  high   low close   volume adjusted\n   <chr>  <date>     <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>\n 1 GOOG   2020-01-02  67.1  68.4  67.1  68.4 28132000     68.1\n 2 GOOG   2020-01-03  67.4  68.6  67.3  68.0 23728000     67.8\n 3 GOOG   2020-01-06  67.5  69.8  67.5  69.7 34646000     69.5\n 4 GOOG   2020-01-07  69.9  70.1  69.5  69.7 30054000     69.4\n 5 GOOG   2020-01-08  69.6  70.6  69.5  70.2 30560000     70.0\n 6 GOOG   2020-01-09  71.0  71.4  70.5  71.0 30018000     70.7\n 7 GOOG   2020-01-10  71.4  71.7  70.9  71.5 36414000     71.2\n 8 GOOG   2020-01-13  71.8  72.0  71.3  72.0 33046000     71.7\n 9 GOOG   2020-01-14  72.0  72.1  71.4  71.5 31178000     71.3\n10 GOOG   2020-01-15  71.5  72.1  71.5  72.0 25654000     71.7\n# ℹ 1,248 more rows\n```\n\n\n:::\n:::\n\n\n:::\n\n## Working with time series objects, Exercise II\n\n-   Another example of using a time series specific functionality is working with leads and lags:\n    1.  Sometimes, we need to shift our variables by a specific interval, like getting the previous day's price\n    2.  Say, for example, that you want to understand how *S&P* returns levels relate to *NFLX* returns one-week ahead\n-   It is relatively straightforward to do it with `tidyquant`:\n    1.  Download *S&P 500* and *NFLX* data using the `tq_get()` function\n    2.  Use `tq_transmute()` to compute the weekly returns for each security based on daily data\n    3.  Use `tq_mutate()` to generate a lagged series of *S&P 500* returns\n\n## Working with time series objects, Exercise II\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Assuming you have already loaded the tidyquant and the tidyverse packages\n\n#Netflix Data\nNFLX=tq_get('NFLX')%>%\n  #Select only the necessary columns\n  select(date,symbol,adjusted)%>%\n  #Apply the weeklyReturn function and call the new column 'NFLX'\n  tq_transmute(mutate_fun = weeklyReturn,\n               col_rename = 'NFLX')\n\n#S&P Data\nSP500=tq_get('^GSPC')%>%\n  #Select only the necessary columns\n  select(date,symbol,adjusted)%>%\n  #Apply the weeklyReturn function and call the new column 'SP500'\n  tq_transmute(mutate_fun = weeklyReturn,\n               col_rename = 'SP500')%>%\n  #Apply the lag function for n=1 week and call the new column 'SP500'\n  tq_transmute(mutate_fun = lag.xts,\n            n=1,\n            col_rename = 'SP500')%>%\n  #Drop all rows with NA information (row 1, in this case)\n  drop_na()\n\n#Merge Data \ninner_join(NFLX,SP500)\n```\n:::\n\n\n\n### Output\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 528 × 3\n   date           NFLX    SP500\n   <date>        <dbl>    <dbl>\n 1 2015-01-09 -0.0563   0      \n 2 2015-01-16  0.0244  -0.00651\n 3 2015-01-23  0.297   -0.0124 \n 4 2015-01-30  0.00992  0.0160 \n 5 2015-02-06  0.00579 -0.0277 \n 6 2015-02-13  0.0489   0.0303 \n 7 2015-02-20  0.0260   0.0202 \n 8 2015-02-27 -0.00688  0.00635\n 9 2015-03-06 -0.0438  -0.00275\n10 2015-03-13 -0.0346  -0.0158 \n# ℹ 518 more rows\n```\n\n\n:::\n:::\n\n\n:::\n\n## Working with time series objects, Exercise III\n\n-   Finance practitioners are often asked to perform analysis on a rolling basis:\n    1.  We may want to calculate a given signal on day $t$ based on past $x$ periods of information\n    2.  Say, for example, that you want to calculate a simple and exponential moving average of adjusted prices from 5 days back for a given stock\n-   It is relatively straightforward to do it with `tidyquant`:\n    1.  Download stock data using the `tq_get()` function\n    2.  Use `tq_mutate()` twice along with the `SMA()` and `EMA()` functions setting `n=5`\n\n## Working with time series objects, Exercise III\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Assuming you have already loaded the tidyquant and the tidyverse packages\n\n#Set up the list of assets\nassets=c('AMZN')\n\nassets%>%\n  tq_get()%>%\n  select(date,symbol,adjusted)%>%\n  group_by(symbol)%>%\n  tq_mutate(adjusted, mutate_fun = SMA, n = 5)%>%\n  tq_mutate(adjusted, mutate_fun = EMA, n = 5)\n```\n:::\n\n\n\n### Output\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,546 × 5\n# Groups:   symbol [1]\n   symbol date       adjusted   SMA   EMA\n   <chr>  <date>        <dbl> <dbl> <dbl>\n 1 AMZN   2015-01-02     15.4  NA    NA  \n 2 AMZN   2015-01-05     15.1  NA    NA  \n 3 AMZN   2015-01-06     14.8  NA    NA  \n 4 AMZN   2015-01-07     14.9  NA    NA  \n 5 AMZN   2015-01-08     15.0  15.0  15.0\n 6 AMZN   2015-01-09     14.8  14.9  15.0\n 7 AMZN   2015-01-12     14.6  14.8  14.8\n 8 AMZN   2015-01-13     14.7  14.8  14.8\n 9 AMZN   2015-01-14     14.7  14.8  14.8\n10 AMZN   2015-01-15     14.3  14.6  14.6\n# ℹ 2,536 more rows\n```\n\n\n:::\n:::\n\n\n:::\n\n## Working with time series objects, Exercise IV\n\n-   Lastly, financial analysts often cover a collection of securities on a rolling basis\n\n-   For example, a buy-side analyst will monitor stocks from a given industry so as to understand which ones are [over]{.red}valued, and which ones are [under]{.green}valued\n\n-   Say, for example, that you want to focus on a subset of 4 stocks, and you need to compare the cumulative return up to the latest closing price\n\n-   It is easy to integrate the `tidyquant` functions along with the `group_by()` function you've learned when working with `dplyr`:\n\n    1.  Get the information using `tq_get()`\n    2.  Group the data by `symbol`\n    3.  Apply the `tq_mutate` and `tq_transmute` functions to pass time series functions to the data - in this case, the `dailyReturn()` and the `Return.cumulative()` function\n\n## Working with time series objects, Exercise IV\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Assuming you have already loaded the tidyquant and the tidyverse packages\n\n#Set up the list of assets\nassets=c('AMZN','GOOG','META','GME')\n\nassets%>%\n  tq_get()%>%\n  select(date,symbol,adjusted)%>%\n  group_by(symbol)%>%\n  tq_mutate(adjusted, mutate_fun = dailyReturn,col_rename = 'daily_return')%>%\n  tq_transmute(daily_return,mutate_fun = Return.cumulative)%>%\n  mutate(across(where(is.numeric),percent,big.mark='.'))%>%\n  setNames(c('Ticker','Cumulative Return up-to-date'))\n```\n:::\n\n\n\n### Output\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n# Groups:   Ticker [4]\n  Ticker `Cumulative Return up-to-date`\n  <chr>  <chr>                         \n1 AMZN   1 382%                        \n2 GOOG   617%                          \n3 META   843%                          \n4 GME    329%                          \n```\n\n\n:::\n:::\n\n\n:::\n\n## Wrapping-up on `tidyquant`\n\n-   There is so much you can use from `tidyquant` in your journey as a quantitative financial analyst:\n\n    1.  I strongly recommend looking at all the predefined functions supported by `tidyquant` - click [here](https://business-science.github.io/tidyquant/articles/TQ02-quant-integrations-in-tidyquant.html) for a detailed discussion around all supported functions\n\n    2.  You can also customize your *own* functions that work with time series (for example, your secret trading indicator) and pass it over through `tq_mutate()` or `tq_transmute()`\n\n-   In the package's [official website](https://business-science.github.io/tidyquant/articles/TQ00-introduction-to-tidyquant.html), you can find a variety of examples to nurture your creativity around what you can do using this package\n\n-   All in all, that's the motto: time series analysis made easy with `tidyquant` and the `tidyverse`\n\n## Does getting ripped increase returns?\n\n::::: columns\n::: {.column width=\"40%\"}\n![](Images/F1.png)\n:::\n\n::: {.column width=\"50%\"}\n![](Images/F2.png)\n:::\n:::::\n\n$\\rightarrow$ See [[*Deadlift: The ETF World’s Latest Headscratcher*](https://finance.yahoo.com/news/deadlift-etf-world-latest-headscratcher-140000992.html)]{.blue}\n\n## Hands-On Exercise\n\n-   Your manager (who did not lift any weights past the last 5 years) wanted to replicate the returns of the *Deadlift ETF* from 2020 to 2024. You job is to create a simple table of yearly returns comparing the *Deadlift ETF* *vis-a-vis* the *S&P 500* Index\n\n-   Follow the instructions and answer to the following questions:\n\n    1.  **When looking at the yearly results from both the *Deadlift ETF* and *S&P 500*, which one did perform better?**\n    2.  **What are the potential explanations for the result you have found?**\n\n-   To answer to these questions, you will be using the a combination of `dplyr` and `tidyquant` functions you have learned so far\n\n-   The expected result is a `data.frame` object that shows both the *Deadlift ETF* as well as the *S&P 500* returns (columns) on a yearly basis (rows)\n\n$\\rightarrow$ *Suggested solution will be provided in the replication file for this lecture.*\n\n## Hands-On Exercise, continued\n\n::: callout-tip\n### Exercise\n\nBefore you start, make sure to have the `tidyverse` and the `tidyquant` packages loaded in your session. Following the instructions from the previous lectures, you can either make a direct call to each package, `library(tidyverse)` and `library(tidyquant)`, or copy-paste the script from the course's [official website](https://lsmacoris.github.io/lectures/quant-fin).\n\n1.  Use `tq_get()` to load information from the *S&P Index* and the *Deadlift ETF* constituents in two separate objects. You can use the code `^GSPC` to retrieve information for the index, and you can pass a vector `c('ticker1','ticker2',...,'ticker_n')` to get information on the *Deadlift ETF* constituents\n2.  Filter for observations starting between 2020 (beginning of) and 2024 (end of) using the `from` and `to` arguments of the `tq_get()` function\n3.  Group the *Deadlift ETF* data by `symbol` using the `group_by()` function\n4.  For both data sets, create a `yearly_ret` variable that calculates the yearly return of a given security. You can use the `tq_transmute()` function, passing the `yearlyReturn()` function along the chain\n5.  For the *Deadlift* data set, regroup the data by `date` and calculate the *Deadlift* returns using a `mutate()` function (*Hint: it is an equally weighted portfolio*)\n6.  Merge both datasets using `inner_join()`\n:::\n\n## Solution\n\n::: panel-tabset\n## Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up the list of assets\ndeadlift=c('META','AMZN','GS','UBER','MSFT','AAPL','BLK','NVDA')\n\n#Set up the starting date\nstart='2020-01-01'\nend='2024-12-31'\n\n#Step 1: Read the Deadlift data using tidyquant\nDeadlift_Performance=deadlift%>%\n  tq_get(from=start,to=end)%>%\n  #Select only the columns of interest\n  select(symbol,date,adjusted)%>%\n  #Group by symbol and date\n  group_by(symbol)%>%\n  #Use tq_transmute to aggregate and calculate weekly returns\n  tq_transmute(selected=adjusted,\n               mutate_fun=yearlyReturn,\n               col_rename = 'Deadlift')%>%\n  #Group by date\n  group_by(date)%>%\n  #Summarize average return (since it is an equally-weighted portfolio)\n  summarize(Deadlift=mean(Deadlift,na.rm=TRUE))\n\n#Step 2: Read the S&P 500 data using tidyquant\nSP500_Performance=tq_get('^GSPC',from=start,to=end)%>%\n  #Select only the columns of interest\n  select(symbol,date,adjusted)%>%\n  #Group by symbol and date\n  group_by(symbol)%>%\n  #Use tq_transmute to aggregate and calculate weekly returns\n  tq_transmute(selected=adjusted,\n               mutate_fun=yearlyReturn,\n               col_rename = 'SP500')%>%\n  ungroup()%>%\n  select(-symbol)\n    \n#Merge\nSP500_Performance%>%\n  inner_join(Deadlift_Performance)%>%\n  mutate(across(where(is.numeric),percent))%>%\n  mutate(date=year(date))%>%\n  setNames(c('Year','S&P 500','DeadLift ETF'))\n```\n:::\n\n\n\n## Output\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n   Year `S&P 500` `DeadLift ETF`\n  <dbl> <chr>     <chr>         \n1  2020 15.29%    57.9%         \n2  2021 26.89%    37.2%         \n3  2022 -19.44%   -36.0%        \n4  2023 24.23%    100.5%        \n5  2024 23.84%    52.1%         \n```\n\n\n:::\n:::\n\n\n:::\n\n## References\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}